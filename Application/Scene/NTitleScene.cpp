#include "NDX12.h"
#include "NTitleScene.h"
#include "NSceneManager.h"
#include "NAudioManager.h"
#include "imgui.h"
#include "NInput.h"
#include "NQuaternion.h"
#include "NMathUtil.h"

NTitleScene* NTitleScene::GetInstance()
{
	static NTitleScene instance;
	return &instance;
}

void NTitleScene::Init()
{
#pragma region	オーディオ初期化
	NAudio::GetInstance()->Init();
	//NAudioManager::Play("WinSE",true,0.2f);
#pragma endregion
#pragma region	カメラ初期化
	camera.ProjectiveProjection();
	camera.CreateMatView();
	NCamera::nowCamera = &camera;
#pragma endregion
#pragma region 描画初期化処理
	//マテリアル(定数バッファ)

	//立方体情報

	//モデル情報
	

	//オブジェクト
	

	//FBX読み込み
	// メッシュの数だけ頂点バッファを用意する
	vertexBuffers.reserve(meshes.size());
	for (size_t i = 0; i < meshes.size(); i++)
	{
		vertexBuffers[i]->Init(meshes[i].vertices);
		indexBuffers[i]->Init(meshes[i].indices);
	}

	const wchar_t* modelFile = L"Resources/FBX/Alicia_solid_Unity.FBX";
	std::vector<Mesh> meshes;

	ImportSettings importSetting = // これ自体は自作の読み込み設定構造体
	{
		modelFile,
		meshes,
		false,
		true // アリシアのモデルは、テクスチャのUVのVだけ反転してるっぽい？ので読み込み時にUV座標を逆転させる
	};

	AssimpLoader loader;
	if (!loader.Load(importSetting))
	{
		
	}

	cb.SetHeap();
	cb.SetResource();
	cb.Create();
	cb.Mapping();

#pragma region オブジェクトの初期値設定
	
#pragma endregion
	//背景スプライト生成

	//前景スプライト生成

#pragma endregion
	// ライト生成
	lightGroup = std::make_unique<NLightGroup>();
	lightGroup = lightGroup->Create();
	// 3Dオブジェクトにライトをセット
	NObj3d::SetLightGroup(lightGroup.get());

	lightGroup->SetDirLightActive(0, true);
	lightGroup->SetDirLightActive(1, true);
	lightGroup->SetDirLightActive(2, true);

	lightGroup->SetPointLightActive(0, false);
	lightGroup->SetPointLightActive(1, false);
	lightGroup->SetPointLightActive(2, false);

	lightGroup->SetCircleShadowActive(0, true);

	timer.SetMaxTimer(10);
}

void NTitleScene::Update()
{
	ImGui::ShowDemoWindow();

	if (NInput::IsKeyDown(DIK_SPACE) || NInput::GetInstance()->IsButtonDown(XINPUT_GAMEPAD_A))
	{
		NSceneManager::SetScene(GAMESCENE);
	}

	if (NInput::IsKeyDown(DIK_RETURN))
	{
		NAudioManager::Play("WinSE", false, 0.5f);
	}

	lightGroup->Update();
#pragma region 行列の計算
	//ビュー行列の再生成
	camera.CreateMatView();
	NCamera::nowCamera = &camera;

	//timer.Update();
	//if (timer.GetisTimeOut())
	//{
	//	obj[0]->position.x = MathUtil::Random(-1.0f, 1.0f);
	//	timer.Reset();
	//}

	//if (isCol)
	//{
	//	obj[0]->model->material.SetColor(255, 0, 0, 255);
	//	NInput::GetInstance()->Vibration(30000, 1000);
	//}
	//else
	//{
	//	obj[0]->model->material.SetColor(255, 255, 255, 255);
	//	NInput::GetInstance()->Vibration(0, 0);
	//}
	//obj[2]->model->material.SetColor(255, 255, 255, 255);

	//sphere.pos = obj[0]->position;
	//NVector3 vec;
	//plane.distance = obj[2]->position.Dot(plane.normal);

	//for (size_t i = 0; i < maxObj; i++)
	//{
	//	obj[i]->UpdateMatrix();
	//}

	//isCol = NCollision::Sphere2PlaneCol(sphere, plane);
#pragma endregion
}

void NTitleScene::Draw()
{
#pragma region グラフィックスコマンド
	//背景スプライト

	//3Dオブジェクト

	// メッシュの数だけインデックス分の描画を行う処理を回す
	for (size_t i = 0; i < meshes.size(); i++)
	{
		auto vbView = vertexBuffers[i]->view; // そのメッシュに対応する頂点バッファ
		auto ibView = indexBuffers[i]->view; // そのメッシュに対応する頂点バッファ

		// パイプラインステートとルートシグネチャの設定コマンド
		NDX12::GetInstance()->GetCommandList()->SetPipelineState(PipeLineManager::GetInstance()->GetPipelineSet3d().pipelineState.Get());
		NDX12::GetInstance()->GetCommandList()->SetGraphicsRootSignature(PipeLineManager::GetInstance()->GetPipelineSet3d().rootSig.entity.Get());

		//ルートパラメータ2番に3D変換行列の定数バッファを渡す
		NDX12::GetInstance()->GetCommandList()->SetGraphicsRootConstantBufferView(2, cb.constBuff->GetGPUVirtualAddress());

		NDX12::GetInstance()->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		NDX12::GetInstance()->GetCommandList()->IASetVertexBuffers(0, 1, &vbView);
		NDX12::GetInstance()->GetCommandList()->IASetIndexBuffer(&ibView);

		NDX12::GetInstance()->GetCommandList()->DrawIndexedInstanced(meshes[i].indices.size(), 1, 0, 0, 0); // インデックスの数分描画する
	}

	//前景スプライト
	

	// 4.描画コマンドここまで
#pragma endregion
}

void NTitleScene::Reset()
{
	// 3Dオブジェクトにライトをセット
	NObj3d::SetLightGroup(lightGroup.get());

	lightGroup->SetDirLightActive(0, true);
	lightGroup->SetDirLightActive(1, true);
	lightGroup->SetDirLightActive(2, true);

	lightGroup->SetPointLightActive(0, false);
	lightGroup->SetPointLightActive(1, false);
	lightGroup->SetPointLightActive(2, false);

	lightGroup->SetCircleShadowActive(0, true);
}

void NTitleScene::Finalize()
{
}